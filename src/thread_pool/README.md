## thread_pool

线程池提供一个高效的方式来并发执行多个任务，特别适用于需要处理大量独立任务的网络服务器。线程池能够有效地管理线程资源，避免了频繁创建和销毁线程的开销。

主要特性：
- 并发执行：允许并行处理多个任务，提高程序的执行效率。
- 资源重用：通过重用已存在的线程，减少了线程创建和销毁的开销。
- 任务队列：使用队列管理待执行的任务，确保按顺序执行。
- 优雅关闭：支持安全地关闭线程池，确保所有任务都能完成后再退出。

**std::shared_ptr**

在这个线程池实现中，使用std::shared_ptr来管理Pool结构的生命周期。Pool结构包含了任务队列、互斥锁、条件变量和关闭标志。通过使用std::shared_ptr，可以确保只要有线程还在运行，Pool的资源就不会被提前释放。

**完美转发**

在添加任务到线程池的AddTask方法中，使用了模板和std::forward来实现完美转发。这允许我们将各种不同类型的函数对象和参数以最高效的方式传递到线程池中，减少不必要的拷贝，提高性能。

**std::vector**

线程池中的工作线程是通过std::vector<std::thread>来管理的。这不仅使得管理多个线程变得简单，而且在关闭线程池时，可以遍历这个向量来逐个加入（join）各个线程，确保所有线程都正确完成任务后再结束程序。

**std::mutex、std::condition_variable**

互斥锁用于保护共享资源，主要是任务队列 (tasks)。条件变量用于线程间的同步。在ThreadPool中，工作线程可能会在没有任务可执行时进入等待状态。这时，它们会通过条件变量进入休眠，直到有新的任务被添加到队列中并通过条件变量被唤醒。这种机制有效地减少了CPU的无效使用，因为它允许线程在没有工作时不占用CPU资源。

在具体实现中，工作线程在尝试从任务队列中取出任务时，如果发现队列为空，就会使用std::unique_lock<std::mutex>加锁，并调用std::condition_variable::wait方法进入等待状态。这个等待可以被以下两种情况之一打断：

- 新任务被添加到队列中：当AddTask方法向队列中添加一个新任务后，它会调用std::condition_variable::notify_one方法，这将唤醒一个正在等待的线程（如果有的话），让它取出任务并执行。

- 线程池关闭：如果调用Close方法关闭线程池，会设置关闭标志(isClosed)并调用std::condition_variable::notify_all。这会唤醒所有等待的线程，这些线程会检查关闭标志，然后退出循环并结束执行。

### usecase

```c++
#include "thread_pool.h"

int main() {
    ThreadPool pool(8);

    pool.AddTask([]() {
        std::cout << "执行任务1" << std::endl;
    });
    pool.AddTask([]() {
        std::cout << "执行任务2" << std::endl;
    });

    // 主线程可以继续执行其他工作，而不需要等待任务完成

    return 0;
}
```