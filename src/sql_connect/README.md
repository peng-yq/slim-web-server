## sql_connect

数据库连接池用于高效地管理MySQL数据库连接。通过使用连接池，我们可以减少频繁打开和关闭数据库连接的开销，提高数据库操作的效率。

**主要特性**

- 连接复用：复用已经建立的数据库连接，减少连接开销。
- 线程安全：确保多线程环境下数据库连接的安全使用。
- 资源控制：限制最大连接数，避免过多的连接耗尽服务器资源。
- 自动管理：通过RAII包装器自动获取和释放数据库连接。

**std::mutex**

互斥锁用于保护mysql连接队列，确保在多线程环境下对队列的访问是安全的。在获取或释放连接时，必须先获取互斥锁，这样可以防止多个线程同时修改连接队列，从而避免数据竞争和潜在的错误。

**sem_t**

信号量用于控制最大mysql可用连接的数量，是一种有效的线程同步机制。初始化时，信号量的值设置为最大连接数。每当一个线程获取一个连接时，信号量减一；每当连接被释放回池中时，信号量加一。如果所有连接都在使用中，信号量值为零，此时任何请求连接的线程都会阻塞，直到有连接被释放回池中。

**单例模式**

使用了单例模式来确保整个程序中只存在一个数据库连接池的实例。利用C++11特性，通过一个静态方法Instance()保证了全局只有一个SqlConnPool实例。这个方法内部使用了一个局部静态变量来存储实例，确保线程安全并且延迟初始化（即在第一次使用时才创建实例）。

**RAII**

通过一个RAII包装类SqlConnRAII来管理数据库连接的获取和释放。这样可以确保即使在发生异常或return early的情况下，数据库连接也总是被正确释放。

注意RAII中传入的参数为MYSQL**，因为获取的sql连接类型为MYSQL\*，如果传入MYSQL\*，接收的是一个指向MYSQL结构的指针的拷贝。在构造函数内部对这个拷贝进行的任何修改（例如改变它指向的地址）都不会影响到原始的指针。这意味着，即使你在SqlConnRAII构造函数中获取了一个新的数据库连接并将其赋给这个拷贝，原始的MYSQL\*变量仍然是未初始化的或指向错误的地址。因此需要传入MYSQL**，并使用\*解引用来更改MYSQL\*的sql连接。

### usecase

```c++
#include "sql_connect_raii.h"

int main() {
    // 初始化连接池
    SqlConnPool* pool = SqlConnPool::Instance();
    pool->Init("localhost", 3306, "user", "password", "dbname", 10);

    // 使用 RAII 获取连接
    MYSQL* conn = nullptr;
    {
        SqlConnRAII mysqlConnRAII(&conn, pool);
        if (conn) {
            // 使用 conn 进行数据库操作
            // ...
        }
    } // 自动释放连接

    return 0;
}
```